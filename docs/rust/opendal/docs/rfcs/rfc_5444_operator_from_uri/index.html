<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Operator from uri"><title>opendal::docs::rfcs::rfc_5444_operator_from_uri - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="opendal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (43a2e9d2c 2025-03-17)" data-channel="nightly" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js"><script src="../../../../static.files/storage-d8ac8691.js"></script><script defer="" src="../sidebar-items.js"></script><script defer="" src="../../../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../../opendal/index.html"><img src="/img/external/71c0d8847d34b7f8ce3fd204c652c6f9.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../../opendal/index.html"><img src="/img/external/71c0d8847d34b7f8ce3fd204c652c6f9.svg" alt="logo"></a><h2><a href="../../../../opendal/index.html">opendal</a><span class="version">0.53.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module rfc_<wbr>5444_<wbr>operator_<wbr>from_<wbr>uri</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#summary" title="Summary">Summary</a></li><li><a href="#motivation" title="Motivation">Motivation</a></li><li><a href="#guide-level-explanation" title="Guide-level explanation">Guide-level explanation</a></li><li><a href="#reference-level-explanation" title="Reference-level explanation">Reference-level explanation</a></li><li><a href="#drawbacks" title="Drawbacks">Drawbacks</a></li><li><a href="#rationale-and-alternatives" title="Rationale and alternatives">Rationale and alternatives</a></li><li><a href="#prior-art" title="Prior art">Prior art</a></li><li><a href="#unresolved-questions" title="Unresolved questions">Unresolved questions</a></li><li><a href="#future-possibilities" title="Future possibilities">Future possibilities</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In opendal::<wbr>docs::<wbr>rfcs</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">opendal</a>::<wbr><a href="../../index.html">docs</a>::<wbr><a href="../index.html">rfcs</a></div><h1>Module <span>rfc_5444_operator_from_uri</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/opendal/docs/rfcs/mod.rs.html#246">Source</a> </span></div><span class="item-info"><div class="stab portability">Available on <strong><code>docsrs</code></strong> only.</div></span><details class="toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Operator from uri</p>
<ul>
<li>Proposal Name: <code>operator_from_uri</code></li>
<li>Start Date: 2024-12-23</li>
<li>RFC PR: <a href="https://github.com/apache/opendal/pull/5444">apache/opendal#5444</a></li>
<li>Tracking Issue: <a href="https://github.com/apache/opendal/issues/5445">apache/opendal#5445</a></li>
</ul>
<h2 id="summary"><a class="doc-anchor" href="#summary">§</a>Summary</h2>
<p>This RFC proposes adding URI-based configuration support to OpenDAL, allowing users to create operators directly from URIs. The proposal introduces a new <code>from_uri</code> API in both the <code>Operator</code> and <code>Configurator</code> traits, along with an <code>OperatorRegistry</code> to manage operator factories.</p>
<h2 id="motivation"><a class="doc-anchor" href="#motivation">§</a>Motivation</h2>
<p>Currently, creating an operator in OpenDAL requires explicit configuration through builder patterns. While this approach provides type safety and clear documentation, it can be verbose and inflexible for simple use cases. Many storage systems are naturally identified by URIs (e.g., <code>s3://bucket/path</code>, <code>fs:///path/to/dir</code>).</p>
<p>Adding URI-based configuration would:</p>
<ul>
<li>Simplify operator creation for common use cases</li>
<li>Enable configuration via connection strings (common in many applications)</li>
<li>Make OpenDAL more approachable for new users</li>
<li>Allow dynamic operator creation based on runtime configuration</li>
</ul>
<h2 id="guide-level-explanation"><a class="doc-anchor" href="#guide-level-explanation">§</a>Guide-level explanation</h2>
<p>The new API allows creating operators directly from URIs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Create an operator using URI
</span><span class="kw">let </span>op = Operator::from_uri(<span class="string">"s3://my-bucket/path"</span>, <span class="macro">vec!</span>[
    (<span class="string">"endpoint"</span>.to_string(), <span class="string">"http://localhost:8080"to_string</span>()),
])<span class="question-mark">?</span>;

<span class="comment">// Users can pass options through the URI along with additional key-value pairs
// The extra options will override identical options specified in the URI
</span><span class="kw">let </span>op = Operator::from_uri(<span class="string">"s3://my-bucket/path?region=us-east-1"</span>, <span class="macro">vec!</span>[
    (<span class="string">"endpoint"</span>.to_string(), <span class="string">"http://localhost:8080"to_string</span>()),
])<span class="question-mark">?</span>;

<span class="comment">// Create a file system operator
</span><span class="kw">let </span>op = Operator::from_uri(<span class="string">"fs:///tmp/test"</span>, <span class="macro">vec!</span>[])<span class="question-mark">?</span>;</code></pre></div>
<p>OpenDAL will, by default, register services enabled by features in a global <code>OperatorRegistry</code>. Users can also create custom operator registries to support their own schemes or additional options.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Using with custom registry
</span><span class="kw">let </span>registry = OperatorRegistry::new();
registry.register(<span class="string">"custom"</span>, my_factory);
<span class="kw">let </span>op = registry.parse(<span class="string">"custom://endpoint"</span>, options)<span class="question-mark">?</span>;</code></pre></div>
<h2 id="reference-level-explanation"><a class="doc-anchor" href="#reference-level-explanation">§</a>Reference-level explanation</h2>
<p>The implementation consists of three main components:</p>
<ol>
<li>The <code>OperatorFactory</code> and <code>OperatorRegistry</code>:</li>
</ol>
<p><code>OperatorFactory</code> is a function type that takes a URI and a map of options and returns an <code>Operator</code>. <code>OperatorRegistry</code> manages operator factories for different schemes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">type </span>OperatorFactory = <span class="kw">fn</span>(http::Uri, HashMap&lt;String, String&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;Operator&gt;;

<span class="kw">pub struct </span>OperatorRegistry { ... }

<span class="kw">impl </span>OperatorRegistry {
    <span class="kw">fn </span>register(<span class="kw-2">&amp;</span><span class="self">self</span>, scheme: <span class="kw-2">&amp;</span>str, factory: OperatorFactory) {
        ...
    }

    <span class="kw">fn </span>parse(<span class="kw-2">&amp;</span><span class="self">self</span>, uri: <span class="kw-2">&amp;</span>str, options: <span class="kw">impl </span>IntoIterator&lt;Item = (String, String)&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;Operator&gt; {
        ...
    }
}</code></pre></div>
<ol start="2">
<li>The <code>Configurator</code> trait extension:</li>
</ol>
<p><code>Configurator</code> will add a new API to create a configuration from a URI and options. OpenDAL will provide default implementations for common configurations. But services can override this method to support their own special needs.</p>
<p>For example, S3 might need to extract the <code>bucket</code> and <code>region</code> from the URI when possible.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>Configurator <span class="kw">for </span>S3Config {
    <span class="kw">fn </span>from_uri(uri: <span class="kw-2">&amp;</span>str, options: <span class="kw">impl </span>IntoIterator&lt;Item = (String, String)&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        ...
    }
}</code></pre></div>
<ol start="3">
<li>The <code>Operator</code> <code>from_uri</code> method:</li>
</ol>
<p>The <code>Operator</code> trait will add a new <code>from_uri</code> method to create an operator from a URI and options. This method will use the global <code>OperatorRegistry</code> to find the appropriate factory for the scheme.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>Operator {
    <span class="kw">pub fn </span>from_uri(
        uri: <span class="kw-2">&amp;</span>str,
        options: <span class="kw">impl </span>IntoIterator&lt;Item = (String, String)&gt;,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        ...
    }
}</code></pre></div>
<p>We are intentionally using <code>&amp;str</code> instead of <code>Scheme</code> here to simplify working with external components outside this crate. Additionally, we plan to remove <code>Scheme</code> from our public API soon to enable splitting OpenDAL into multiple crates.</p>
<h2 id="drawbacks"><a class="doc-anchor" href="#drawbacks">§</a>Drawbacks</h2>
<ul>
<li>Increases API surface area</li>
<li>Less type safety compared to builder patterns</li>
<li>Potential for confusing error messages with invalid URIs</li>
<li>Need to maintain backwards compatibility</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="doc-anchor" href="#rationale-and-alternatives">§</a>Rationale and alternatives</h2>
<p>Alternatives considered:</p>
<ol>
<li>Connection string format instead of URIs</li>
<li>Builder pattern with URI parsing</li>
<li>Macro-based configuration</li>
</ol>
<p>URI-based configuration was chosen because:</p>
<ul>
<li>URIs are widely understood</li>
<li>Natural fit for storage locations</li>
<li>Extensible through custom schemes</li>
<li>Common in similar tools</li>
</ul>
<h2 id="prior-art"><a class="doc-anchor" href="#prior-art">§</a>Prior art</h2>
<p>Similar patterns exist in:</p>
<ul>
<li>Database connection strings (PostgreSQL, MongoDB)</li>
<li><a href="https://docs.rs/object_store/latest/object_store/fn.parse_url.html"><code>object_store::parse_url</code></a></li>
</ul>
<h2 id="unresolved-questions"><a class="doc-anchor" href="#unresolved-questions">§</a>Unresolved questions</h2>
<p>None</p>
<h2 id="future-possibilities"><a class="doc-anchor" href="#future-possibilities">§</a>Future possibilities</h2>
<ul>
<li>Support for connection string format.</li>
<li>Configuration presets like <code>r2</code> and <code>s3</code> with directory bucket enabled.</li>
</ul>
</div></details></section></div></main></body></html>